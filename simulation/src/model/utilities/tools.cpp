

#include <algorithm> 
#include <vector>
#include <random>
#include <complex>
#include <iostream>
#include <chrono>

#include "tools.h"
#include "../typevector.h"





vec1D random_nb_array(double start, double end, int size_arr) {

    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    static std::default_random_engine gen(seed);

    std::uniform_real_distribution<> dis(start, end);
    std::vector<double> result;
    for (int n = 0; n < size_arr; ++n) {
        // Use dis to transform the random unsigned int generated by gen into a double. Each call to dis(gen) generates a new random double.
        result.push_back(dis(gen));
    }
    return result;
}



double standard_deviation(vec1D arr) {

    if (arr.size() == 0) {
        return 0.0;
    }

    double s = 0.0;
    double sq_s = 0.0;

    for (int i = 0; i < arr.size(); i++) {
        s += arr[i];
        sq_s += arr[i] * arr[i];
    }

    double mean = s / arr.size();
    double var = (sq_s / arr.size()) - mean * mean;

    return sqrt(var);
}



//returns an array containing the interpolated points given in arguments
vec1D l_interp(vec1D& x, vec1D& xp, vec1D& fp) {

    //Need verify that xp and fp have the same size

    const int a = x.size() / xp.size(); //must be always >1 

    vec1D y(x.size(), 0.);

    for (int i = 1; i < xp.size(); i++) {
        y[(i - 1) * a] = fp[i - 1];

        double slope = (fp[i] - fp[i - 1]) / (xp[i] - xp[i - 1]);

        for (int j = 1; j < a; j++) {

            y[(i - 1) * a + j] = slope * (x[(i - 1) * a + j] - x[(i - 1) * a]) + y[(i - 1) * a];

        }
    }

    //For the remainings terms

    for (int u = x.size() - a; u < x.size(); u++) {
        y[u] = fp.back();
    }
    return y;

}


//Resample vectors of vectors
vec2D resample(vec2D vec, int res_factor) {

    //TODO : check if "row" and "column" have the same size

    int dimrow = vec.size();
    int dimcol = vec[0].size();

    vec2D res(ceil((float)vec.size() / res_factor), vec1D(dimcol));

    for (int i = 0; i < res.size(); ++i) {
        res[i] = vec[i * res_factor];
    }
    return res;
}
